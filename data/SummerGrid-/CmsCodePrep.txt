%META:TOPICINFO{author="AnneHeavey" date="1182464740" format="1.1" version="1.6"}%
%META:TOPICPARENT{name="CmsHiggsDemo"}%
---+ Prepare your CMS code

%TOC{title="Outline:"}% 

---++ Create your Higgs analysis module:
You'll use the framework template script to make the module. From your =CMSSW_1_2_0/src/Demo= directory, run the command:
<verbatim style="background-color: lightblue;  text-align: left; font-weight: 700; padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
mkedanlzr -track MyTrackAnalyzer
</verbatim>

---++ Edit your *BuildFile* _(CMS makefile)_
The !BuildFile describes what your module will produce and what dependencies it has. You need to add "root" to the generic file that appears in your 
=Demo/MyTrackAnalyzer/= area. ROOT is an object-oriented (OO) data analysis framework.  If that's Greek to you (colloquial for "incomprehensible"), don't worry, you can still do the demo!  
Edit the build file as follows, inserting the text in red as shown. Do not overwrite anything.
<verbatim style="background-color: lightgrey;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
<use name=FWCore/Framework>
<use name=Foundation/PluginManager>
<use name=FWCore/ParameterSet>
<flags SEAL_PLUGIN_NAME="DemoMyTrackAnalyzer">
<use name=DataFormats/TrackReco>
</verbatim>
<verbatim style="background-color: red;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
<use name=root>
</verbatim>
<verbatim style="background-color: lightgrey;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
<export>
   <lib name=DemoMyTrackAnalyzer>
   <use name=FWCore/Framework>
   <use name=Foundation/PluginManager>
   <use name=FWCore/ParameterSet>
   <use name=DataFormats/TrackReco>
</verbatim>
<verbatim style="background-color: red;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
   <use name=root>
</verbatim>
<verbatim style="background-color: lightgrey;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
</export>
</verbatim>

---++ Edit your module
You'll need to add analysis code and an output ROOT file for histograms to your module, =Demo/MyTrackAnalyzer/src/MyTrackAnalyzer.cc=.  For the Higgs search, we want to look at:
   * transverse momentum of reconstructed tracks: p<sub>T</sub> [GeV]
   * di-track invariant mass: m<sub>mu,mu</sub> [GeV]
   * invariant mass of two di-track-objects: m<sub>Z,Z</sub> [GeV]

Edit your module as shown, inserting the red parts:

<verbatim style="background-color: lightgrey;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
// -*- C++ -*-
//
// Package:    MyTrackAnalyzer
// Class:      MyTrackAnalyzer
// 
/**\class MyTrackAnalyzer MyTrackAnalyzer.cc Demo/MyTrackAnalyzer/src/MyTrackAnalyzer.cc

 Description: <one line class summary>

 Implementation:
     <Notes on implementation>
*/
//
// Original Author:  Oliver Gutsche
//         Created:  Mon Jan 15 10:28:42 CST 2007
// $Id: MidWestGridWorkshop2007Code.txt,v 1.1 2007/03/24 22:32:17 OliverGutsche Exp $
//
//


// system include files
#include <memory>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/ParameterSet/interface/InputTag.h"
#include "DataFormats/TrackReco/interface/Track.h"

</verbatim>
<verbatim style="background-color: red;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
#include "TH1D.h"
#include "TFile.h"
#include "TLorentzVector.h"
</verbatim>
<verbatim style="background-color: lightgrey;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">

//
// class decleration
//

class MyTrackAnalyzer : public edm::EDAnalyzer {
   public:
      explicit MyTrackAnalyzer(const edm::ParameterSet&);
      ~MyTrackAnalyzer();

   private:
      virtual void beginJob(const edm::EventSetup&) ;
      virtual void analyze(const edm::Event&, const edm::EventSetup&);
      virtual void endJob() ;

      // ----------member data ---------------------------
      edm::InputTag trackTags_; //used to select what tracks to read from configuration file
</verbatim>
<verbatim style="background-color: red;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
      TH1D *pt_;
      TH1D *mmumu_;
      TH1D *mzz_;
      TFile *file_;
</verbatim>
<verbatim style="background-color: lightgrey;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
};

//
// constants, enums and typedefs
//

//
// static data member definitions
//

//
// constructors and destructor
//
MyTrackAnalyzer::MyTrackAnalyzer(const edm::ParameterSet& iConfig)
:
 trackTags_(iConfig.getUntrackedParameter<edm::InputTag>("tracks"))
{
   //now do what ever initialization is needed
</verbatim>
(Note the =histograms.root= file definition below; you'll use this in your !CRAB config file.)
<verbatim style="background-color: red;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
   file_ = new TFile("histograms.root","RECREATE");

   pt_ = new TH1D("pt","Track p_{T}",250,0.,250.);
   pt_->Sumw2();
   pt_->SetXTitle("p_{T} [GeV]");
   pt_->SetYTitle("Events");

  mmumu_ = new TH1D("mmumu","m_{#mu#mu}",250,0.,250.);
  mmumu_->Sumw2();
  mmumu_->SetXTitle("m_{#mu#mu} [GeV]");
  mmumu_->SetYTitle("Events");

  mzz_ = new TH1D("mzz","m_{ZZ}",250,0.,250.);
  mzz_->Sumw2();
  mzz_->SetXTitle("m_{ZZ} [GeV]");
  mzz_->SetYTitle("Events");
</verbatim>
<verbatim style="background-color: lightgrey;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">

}


MyTrackAnalyzer::~MyTrackAnalyzer()
{
 
   // do anything here that needs to be done at desctruction time
   // (e.g. close files, deallocate resources etc.)

</verbatim>
<verbatim style="background-color: red;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
  file_->Write();
  file_->Close();
</verbatim>
<verbatim style="background-color: lightgrey;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">

}


//
// member functions
//

// ------------ method called to for each event  ------------
void
MyTrackAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
   using namespace edm;
   using reco::TrackCollection;
  
   Handle<TrackCollection> tracks;
   iEvent.getByLabel(trackTags_,tracks);
   for(TrackCollection::const_iterator itTrack = tracks->begin();
       itTrack != tracks->end();
       ++itTrack) {
</verbatim>
(You may have a line in the original file to overwrite here: int charge ...)
<verbatim style="background-color: red;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
     pt_->Fill(itTrack->pt());
     std::vector<TLorentzVector> mumus;
     TLorentzVector track1(itTrack->px(),itTrack->py(),itTrack->pz(),std::sqrt(itTrack->p()*itTrack->p()+0.10566*0.10566));
     for(TrackCollection::const_iterator itTrack2 = tracks->begin();
         itTrack2 != tracks->end();
         ++itTrack2) {
       if ( itTrack->charge() != itTrack2->charge() ) {
         TLorentzVector track2(itTrack2->px(),itTrack2->py(),itTrack2->pz(),std::sqrt(itTrack2->p()*itTrack2->p()+0.10566*0.10566));
         TLorentzVector mumu = track1 + track2;

         mmumu_->Fill(mumu.M());
         mumus.push_back(mumu);

       }
     }

     if ( mumus.size() > 1 ) {
       for ( std::vector<TLorentzVector>::iterator mumu1 = mumus.begin();
             mumu1 != mumus.end();
             ++mumu1) {
         if ( mumu1->M() > 80. && mumu1->M() < 100.0 ) {
           for ( std::vector<TLorentzVector>::iterator mumu2 = mumu1+1;
                 mumu2 != mumus.end();
                 ++mumu2) {
             if ( mumu2->M() > 80. && mumu2->M() < 100.0 ) {
               TLorentzVector zz = *mumu1 + *mumu2;
               mzz_->Fill(zz.M());
             }
           }
         }
       }
     }
</verbatim>
<verbatim style="background-color: lightgrey;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
  }
}


// ------------ method called once each job just before starting event loop  ------------
void 
MyTrackAnalyzer::beginJob(const edm::EventSetup&)
{
}

// ------------ method called once each job just after ending the event loop  ------------
void 
MyTrackAnalyzer::endJob() {
}

//define this as a plug-in
DEFINE_FWK_MODULE(MyTrackAnalyzer);
</verbatim>
---++ Use the !BuildFile to build (compile) your module
You've edited your !BuildFile and your code; now compile the code. In the =Demo/MyTrackAnalyzer= directory, run this one easy command:
<verbatim style="background-color: lightblue;  text-align: left; font-weight: 700; padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
scramv1 b
</verbatim>

---++ Configure your module
You need a configuration file (also called a "parameter set" in CMSSW).  In the =Demo/MyTrackAnalyzer/test= directory, create a new file called =demotest.cfg=, and give it the following contents:
<verbatim style="background-color: lightgrey;  text-align: left;padding: 10px;margin-left: 20px;margin-right: 20px;color: black;">
process A = {

  source = PoolSource {
        untracked vstring fileNames = {
                "file:test.root"
        }
        untracked int32 maxEvents = -1
        untracked uint32 skipEvents = 0
  }

  module higgs = MyTrackAnalyzer {
        untracked InputTag tracks = ctfWithMaterialTracks
  }

  path p = {
        higgs
  }

}
</verbatim>
---
Now, go to [[CmsHiggsDemo#Find_the_dataset]["Find a dataset"]] on the [[CmsHiggsDemo][main demo page]], and continue there. 
---
-- Main.AnneHeavey - June 2007 (adapted from Oliver Gutsche)
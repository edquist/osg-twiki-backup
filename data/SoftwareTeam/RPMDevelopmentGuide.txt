%META:TOPICINFO{author="MatyasSelmeci" date="1311189496" format="1.1" version="1.29"}%
---+ RPM Development Guide

This page documents technical guidelines and details about RPM development for the OSG Software Stack. The procedures, conventions, and policies defined within are used by the OSG Software Team, and are recommended to all external developers who wish to contribute to the OSG Software Stack.

%RED%Status:%ENDCOLOR% This page was spun off of the [[NPTransition][Native Packaging Transition]] page. We expect the details herein to change significantly and frequently over the next few weeks (late June – early July, 2011) as our understanding of the problems and possible solutions becomes more clear.

---++ Principles

The principles below guide the design and implementation of the technical details that follow.

   * Packages should adhere to community standards (e.g., [[http://fedoraproject.org/wiki/PackagingGuidelines][Fedora Packaging Guidelines]]) when possible, and significant deviations must be documented
   * Every released package must be reproducible from data stored in our system
   * Upstream source files (which should not be modified) should be clearly separated from files owned by the OSG Software Team
   * Building source and binary packages from our system should be easy and efficient
   * External developers should have a clear and effective system for developing and contributing packages
   * We should use standard tools from relevant packaging and development communities when appropriate

---++ Development Infrastructure

This section documents most of what a developer needs to know about our RPM infrastructure:

   * Upstream Source Cache — a filesystem scheme for caching upstream source files
   * Revision Control System — where to get and store development files, and how they are organized
   * Build System — how to build packages from the revision control system
   * Development Tools — other tools to aid development
   * Yum Repository — the location and organization of our Yum repository, and how to promote packages through it

---+++ Becoming a Contributor

We encourage all interested parties to contribute to OSG Software, and all the infrastructure described on this page should be friendly to external contributors.

*However*, not all of the infrastructure is in place yet: you must gather a few authorizations.  We will be working to decrease the extra steps necessary:
   * To participate in the packaging community: You must subscribe to the osg-software@opensciencegrid.org email list.  Subscribing to an OSG email list is [[http://listserv.fnal.gov/users.asp#subscribe%20to%20list][described here]].
   * To create and edit packages: [[http://vdt.cs.wisc.edu/internal/svn.html][Obtain access to VDT SVN]].
   * To upload new source tarballs: You must have a cs.wisc.edu account with write access to the VDT source tarball directory.  Email the osg-software list and request permission.

---+++ Upstream Source Cache

One of our principles (every released package must be reproducible from data stored in our system) creates a potential issue: If we keep all historical source data, especially upstream files like source tarballs and source RPMs, in our revision control system, we may face large checkouts and consequently long checkout and update times.

Our solution is to cache all upstream source files in a separate filesystem area, retaining historical files indefinitely. To avoid tainting upstream files, our policy is to leave them unmodified after download.

%RED%Proposed extension:%ENDCOLOR% Immediately after caching an upstream source file, save its hash in a file of the same name with a hash-appropriate extension. This extra step could be added at any time in the future.

---++++ Locating Files in the Cache

Upstream source files are stored in the filesystem as follows:

<blockquote><code><em>%GREEN%prefix%ENDCOLOR%</em>/<em>%GREEN%package%ENDCOLOR%</em>/<em>%GREEN%version%ENDCOLOR%</em>/<em>%GREEN%file%ENDCOLOR%</em></code></blockquote>

where:

%TABLE{sort="off"}%
| *Symbol* | *Definition* | *Example* |
| <code><em>%GREEN%prefix%ENDCOLOR%</em></code> | Filesystem prefix, the base location of the upstream source cache | At Madison: =/p/vdt/public/html/upstream= |
| <code><em>%GREEN%package%ENDCOLOR%</em></code> | Upstream name of the source package, or some widely accepted form thereof | =ndt= |
| <code><em>%GREEN%version%ENDCOLOR%</em></code> | Upstream version string used to identify the release | =3.6.4= |
| <code><em>%GREEN%file%ENDCOLOR%</em></code> | Upstream filename itself (unless filename conflicts force a change, which should be exceedingly rare) | =ndt-3.6.4.tar.gz= |

The authoritative cache is the VDT webserver, which is fully backed up. Other developers can create a local cache for efficient development. %RED%Need submission process.%ENDCOLOR%

Upstream source files are referenced from within the revision control system; see below for details.

---+++ Revision Control System

All packages that the OSG Software Team releases are checked into our revision control system (currently Subversion %RED%but leaning toward git%ENDCOLOR%). We %RED%will%ENDCOLOR% allow collaborators to commit to the repository.

---++++ Subversion Access

Our Subversion repository is located at:

<blockquote><pre>https://vdt.cs.wisc.edu/svn</pre></blockquote>

[[http://vdt.cs.wisc.edu/internal/svn.html][Procedure for offsite users obtaining access to Subversion]]

Or, from a UW–Madison Computer Sciences machine:

<blockquote><pre>file:///p/condor/workspaces/vdt/svn</pre></blockquote>

The current SVN directory housing our work-in-progress native package work is =$repo/native= (where =$repo= is one of the ways of accessing our SVN repository above). For example, to check out the current Subversion repository via https, do:

<pre class="screen">
svn co https://vdt.cs.wisc.edu/svn/native
</pre>

---++++ Top-Level Directory Organization

The top levels of our Subversion directory hierarchy are as follows:

<blockquote><code>native/<em>%GREEN%os%ENDCOLOR%</em>/<em>%GREEN%section%ENDCOLOR%</em>/<em>%GREEN%package%ENDCOLOR%</em></code></blockquote>

where:

%TABLE{sort="off"}%
| *Symbol* | *Definition* | *Example* |
| <code><em>%GREEN%os%ENDCOLOR%</em></code> | Major operating system release | =redhat= (only supported value, currently) |
| <code><em>%GREEN%section%ENDCOLOR%</em></code> | Development section | %RED%May be one of the standard Subversion sections like =trunk=, =branches/*=, and =tags/*= %ENDCOLOR% |
| <code><em>%GREEN%package%ENDCOLOR%</em></code> | Our standardized name for a source package | =ndt= |

---++++ Package Directory Organization

Within a source package directory, the following files (detailed in separate sections below) may exist:

| =README= | text file | package notes, by and for developers |
| =upstream/= | directory | references to the upstream source cache %RED%(and maybe other kinds of upstream files, someday)%ENDCOLOR% |
| =osg/= | directory | overrides and patches of upstream files, plus new files, which contribute to the final OSG source package |
| =_upstream_srpm_contents/= | generated directory (not under revision control) | expanded contents of a cached upstream source package |
| =_upstream_tarball_contents/= | generated directory (not under revision control) | expanded contents of all cached upstream source tarballs |
| =_final_srpm_contents/= | generated directory (not under revision control) | the final contents of the OSG source package |
| =_build_results/= | generated directory (not under revision control) | OSG source and binary packages resulting from a build |
| =_nmi_prebuild/= | generated directory (not under revision control) | temporary directory used to store files to be uploaded to nmi for the batlab task |

---+++++ README

This is a free-form text file for developers to leave notes about the package.

---+++++ upstream

Within the per-package directories of the revision control system, there must be a way to refer to cached files. This is done with small text files that (a) are named consistently, and (b) contain the location of the referenced file as its only contents.

A reference file is named:

<blockquote><code><em>%GREEN%description%ENDCOLOR%</em>.<em>%GREEN%type%ENDCOLOR%</em>.source</code></blockquote>

where:

%TABLE{sort="off"}%
| *Symbol* | *Definition* | *Example* |
| <code><em>%GREEN%description%ENDCOLOR%</em></code> | Descriptive label of the source of the referenced file | =developer=, =epel=, =emi= |
| <code><em>%GREEN%type%ENDCOLOR%</em></code> | Type of referenced file | Use: =tarball=, =srpm= |

The contents of the file match the upstream source cache path defined above, without the prefix component:

<blockquote><code><em>%GREEN%package%ENDCOLOR%</em>/<em>%GREEN%version%ENDCOLOR%</em>/<em>%GREEN%file%ENDCOLOR%</em></code></blockquote>

This way, the command-line tools that use the =.source= files can be given different prefixes for different build situations.

For example, the reference file for NDT’s source tarball is named =developer.tarball.source= and might contain:

<blockquote><code>ndt/3.6.4/ndt-3.6.4.tar.gz</code></blockquote>

---+++++ osg

The =osg= directory contains files that are owned by the OSG Software Team and that are used to create the final, released source package. It may contain a variety of development files:

   * A =root= subdirectory, which contains files, organized in FHS subdirectories, to be installed by the package; only to be used when there is no =upstream= subdirectory for the given package
   * An RPM =.spec= file, which overrides any spec file from a referenced source
   * Patch (=.patch=) or replacement files, which override any same-named file from the top-level directory of a referenced source
   * Other files, which must be explicitly placed into the package by the spec file

---+++++ _upstream_srpm_contents

The =_upstream_srpm_contents= directory contains the files that are part of the upstream source package. It is generated by the package build tool and is a volatile record of the upstream source for developer use. This directory is excluded from Subversion commits.

---+++++ _upstream_tarball_contents

The =_upstream_tarball_contents= directory contains the files that are part of the upstream source tarballs. It is generated by the package build tool if and only if the =--full-extract= option is passed. It is not used for anything by the build tool, but meant as a convenience to allow the developer to look inside the upstream sources (for making patches, etc.). This directory is excluded from Subversion commits.

---+++++ _final_srpm_contents

The =_final_srpm_contents= directory contains the final files that are part of the released source package. It is generated by the package build tool and is a volatile record of a build for developer use. This directory is excluded from Subversion commits.

---+++++ _build_results

The =_build_results= directory contains the source and binary RPMs that are produced by a local build. The directory is generated by the package build tool and is a volatile record of a build for developer use. It is excluded from Subversion commits.

---+++++ _nmi_prebuild

A temporary directory used for the =batlab= task containing the files to be uploaded to the submit host.

---+++++ Use Case 1: Packaging Our Own Code

When the OSG Software Team contributes all of the files for a package, they are located in the <code>osg/root</code> directory, and then there is a spec file. For example, the OSG Software Team provides a debugging utility called <code>vdt-system-profiler</code> to collect system information that can be sent to the OSG Software Team to aid in debugging. Its package directory contains:

<blockquote>
<pre>
vdt-system-profiler/
    osg/
        root/usr/bin/vdt-system-profiler
        root/usr/share/man/man1/vdt-system-profiler.1
        vdt-system-profiler.spec
</pre>
</blockquote>

---+++++ Use Case 2: Packaging an Upstream Source Tarball

When the OSG Software Team packages an upstream source tarball, for which there is no existing package, the source tarball is referenced with a .source file and we provide a spec file and, if necessary, patches. For example, RSV is provided as a source tarball only. Its package directory contains:

<blockquote>
<pre>
osg-rsv/
    osg/
        osg-rsv.spec
    upstream/
        developer.tarball.source
</pre>
</blockquote>

---+++++ Use Case 3: Passing Through a Source RPM

When the OSG Software Team simply provides a copy of an existing source RPM, it is referenced with a .source file and that is it. For example, we do not modify the xrootd source RPM from EMI. Its package directory contains:

<blockquote>
<pre>
xrootd/
    upstream/
        developer.srpm.source
</pre>
</blockquote>

---+++++ Use Case 4: Modifying a Source RPM

When the OSG Software Team modifies an existing source RPM, it is referenced with a .source file and then all changes to the upstream source are contained in the <code>osg</code> directory. For example, *if we were to ship a modified Apache HTTPD webserver package,* we would use this mechanism. Its package directory contains:

<blockquote><pre>
apache/
    osg/
        httpd.spec
        vdt-apachectl.patch
    upstream/
        epel.srpm.source
</pre></blockquote>

---+++ Build Process

We have a few conflicting desires. We want to use community-accepted tools (such as mock and Koji), we want to take advantage of the Batlab at the University of Wisconsin–Madison, and we want to make it easy for external contributors to provide RPMs. How do we balance these?

---++++ Officially Supported Packages

   1. All necessary information to create the package will be committed to the VDT source code repository (see below)
   1. A tool will be provided that will take those files, create a source RPM, and submit it to a build system; initially we will support three underlying build systems:
      * rpmbuild
      * mock
      * Metronome (the Batlab build system); this build system will use mock, so it's very similar to option 2

Official builds will be done with Metronome, but contributors can use options 1 or 2 to develop a package before contributing it to the OSG Software Stack.

Initially this will be all we support. In the near future, we will likely have our Metronome builds provide build information to a VDT-owned Koji instance. As we gain expertise with Koji, we may add support for directly using Koji. 

We will implement these build options in the order they are presented. This will allow us to quickly get up to speed in producing !RPMs.

---++++ Unsupported Contributed Packages

Unsupported contributed packages have two build options. They will be provided via a separate yum repository for unsupported contributions.

   1. Build exactly like the supported packages (above). 
   1. The RPM can be built by the contributor in their own environment and shared with the OSG Software Team for manual staging into the yum repository. 

Should we support Koji in the future, we'll allow Koji submissions for trusted contributors. 

---++++ Build Tools

The revision control system contains a script to help with developing and building source and binary RPMs. %RED%Eventually, we should put all of our developer tools into an RPM.%ENDCOLOR%

---+++++ Synopsis

<blockquote><code>vdt-build <em>command</em> [options] <em>package</em> [...]</code></blockquote>

---+++++ Commands

---++++++ =prebuild=

Prebuilds the final source package from upstream sources (if any) and local files (if any). May create or overwrite the =_upstream_srpm_contents= and =_final_srpm_contents= directories.

---++++++ =rpmbuild=

Prebuilds the final source package, then builds it locally using =rpmbuild=, and stores the resulting source and binary RPMs in the package-specific =_build_results= directory. By default, this command *does not* push the resulting packages into Yum, but see the =--push-to-yum= and =--yum-base= options for more information.

---++++++ =mock=

Prebuilds the final source package, then builds it locally using =mock=, and stores the resulting source and binary RPMs in the package-specific =_build_results= directory. By default, *does* push the resulting packages into the yum repository specified in a configuration file (unimplemented), but see the =--no-push-to-yum= and =--yum-base= options for more information.

---++++++ =push=

Pushes existing RPMs to yum repositories specified by the =--yum-base= argument or a configuration file (unimplemented). Can be given either a package directory or a list of rpm files as arguments.

---++++++ =batlab=

Prebuilds the final source package, then builds it remotely using the UW–Madison Build And Test Lab (BATLab) and, if successful, copies the resulting source and binary RPMs to the development section of the Yum repository. (Partially implemented)

---+++++ Options

---++++++ =--help=

Prints the built-in usage information and exits without doing anything else.

---++++++ =-c=, =--cache-prefix= _prefix_

Sets the _prefix_ for upstream source cache references. The prefix must be a valid URI starting with either =http=, =https=, or =file=. The upstream source cache must be organized as described above. All files referenced by =.source= files in the affected packages must exist in the cache, or a runtime error will occur. If not specified, defaults to =http://vdt.cs.wisc.edu/upstream/=.

---++++++ =-C=, =--config-file= _config_file_

Sets the configuration file to load for the =vdt-build= script, which can contain default values of options. The default path for the configuration file is =$HOME/.vdt-build.ini=. A sample configuration file is provided at =/usr/share/doc/vdt-build/sample-vdt-build.ini= for an RPM install of =vdt-build= or =tools/vdt-build/sample-vdt-build.ini= for an SVN checkout.

---++++++ =-e=, =--email= _email_

Sets the email address to be used for notifications of job success/failure for the =batlab= task.

---++++++ =--full-extract=

If set, all upstream tarballs will be extracted into =_upstream_tarball_contents/= during the prebuild step.

---++++++ =-p=, =--push-to-yum=

Adds resulting RPMs to a Yum repository, i.e. copies the RPMs and reindexes the affected repositories. Currently, the repository must be specified by =--yum-base=, but in the future a configuration file can specify this. See below for repository layout.

---++++++ =--nop=, =--no-push-to-yum=

Do not add resulting RPMs to a Yum repository.

---++++++ =-m=, =--mock-config= _path_

Specifies the =mock= configuration file to use with the =mock= command. This file details how to set up the build environment used by mock for the build, including Yum repositories from which to install dependencies and certain predefined variables (e.g., the distribution tag =%dist=).

The special value =AUTO= generates a configuration file that uses the VDT, Centos 5 and EPEL 5 repositories for the current architecture. Centos 5 will be changed to Scientific Linux 5 once a suitable mock config file is obtained.

---++++++ =--nmi-submit-machine= _machine_

The machine in the NMI Build and Test lab to submit jobs for the =batlab= task to.

---++++++ =-w=, =--working-directory= _path_

Use _path_ as the root directory of the files created by the script. For example, if _path_ is =$HOME/working=, and the package being built is =ndt=, the following tree will be created:
   * $HOME/working/ndt/_upstream_srpm_contents
   * $HOME/working/ndt/_upstream_tarball_contents
   * $HOME/working/ndt/_final_srpm_contents
   * $HOME/working/ndt/_build_results
If _path_ is =TEMP=, a randomly named directory under =/tmp= is used as the working directory.

---++++++ =-y=, =--yum-base= _path_

Identifies the filesystem path at which the Yum repositories are based. For the commands that attempt to install source and binary RPMs into Yum, this prefix is used to locate the Yum repositories. Implies =--push-to-yum=.

---++++++ =--init-repos=

If the Yum repositories tree to write to doesn't exist (see =--yum-base=), create it.
This invocation creates the following tree:

<code>vdt-build rpmbuild ndt --init-repos -y $HOME/repos</code>
   * $HOME/repos/i386
   * $HOME/repos/x86_64
   * $HOME/repos/noarch
   * $HOME/repos/src

---++++++ =-q=, =--quiet=

Do not display as much information.

---+++ OSG Software Repository

The OSG Software Team maintains a Yum repository, or technically, a set of parallel Yum repositories that contain our source and binary RPMs. The repository is contained within the VDT webserver, organized as follows:

<blockquote><code>http://vdt.cs.wisc.edu/repos/<em>%GREEN%version%ENDCOLOR%</em>/<em>%GREEN%os%ENDCOLOR%</em>/<em>%GREEN%level%ENDCOLOR%</em>/<em>%GREEN%architecture%ENDCOLOR%</em>/*.rpm</code></blockquote>

where:

%TABLE{sort="off"}%
| *Symbol* | *Definition* | *Example* |
| <code><em>%GREEN%version%ENDCOLOR%</em></code> | Major-minor version of the VDT | =3.0= |
| <code><em>%GREEN%os%ENDCOLOR%</em></code> | Major operating system release for which packages were built | =el5= (only supported value, currently) |
| <code><em>%GREEN%level%ENDCOLOR%</em></code> | Release level of the package (see below) | =development=, =testing=, =production=, =contrib= |
| <code><em>%GREEN%architecture%ENDCOLOR%</em></code> | Architecture of the built packages | =i386=, =x86_64=, =source=, =noarch= |

Technically, every combination of VDT version, operating system, level, and architecture (except =noarch=) is a single Yum repository.

Example:

<blockquote><code>http://vdt.cs.wisc.edu/repos/3.0/el5/production/i386/*.rpm</code></blockquote>

---++++ Release Levels

Every package is classified into a release level based on the amount of testing it has undergone and our confidence in its stability. When a package is first built, it goes into the lowest level (=development=). Only members of the OSG Software Team may promote packages upward through the release levels.

%TABLE{sort="off"}%
| *Level* | *Intended Use* | *Intended Users* |
| =development= | Internal testing only; bleeding-edge and volatile | OSG Software Team and external contributors |
| =test= | External testing | OSG Software Team, external contributors, the ITB and other testers |
| =production= | General use, including on production systems | Most site administrators and users |
| =contrib= | General use, with caution — unsupported software with less testing | Some site administrators and users |

Contrary to past practice, when there were separate repositories for _the VDT_ and _the OSG software cache_, we will have a single shared repository. The GOC will continue to maintain the packages they have maintained (such as the VO configuration information), but will provide it via our mechanisms.

---++++ Package and Repository Signing

%RED%All TBD. How we sign: one key for team vs. key for individuals. How does koji handle this?%ENDCOLOR%

---++ Packaging Conventions

In addition to adhering to the [[http://fedoraproject.org/wiki/PackagingGuidelines][Fedora Packaging Guidelines]] (FPG), we have a few rules and guidelines of our own:

   * %RED% We may require packages that do not meet all FPG guidelines to install a file (perhaps in <code>/usr/share/doc/%GREEN%package%ENDCOLOR%/</code>) that documents major deviations from the guidelines that may be significant to end users.%ENDCOLOR%

   * %RED% We should probably provide a more user-level README file in /usr/share/doc/package as well, if a package doesn't come with some form of documentation.%ENDCOLOR%

   * Packages we create or modify should have a distro tag in the release (put =%{?dist}= at the end of the release).

---++ Testing

Pre-release and after-release against updated versions

---++ External RPM Repositories

---+++ EPEL & Globus & VOMS

We will tell our users that they have to use/enable the EPEL repository.

Initially, we will only copy Globus from EPEL when we need to patch it. We expect that we only need to patch a small subset of the Globus packages, so most will come from EPEL. We don't yet have a good feeling for whether or not we can rely on EPEL, so we reserve the right to copy more RPMs from EPEL in the future, if necessary.

When we copy packages, we will add a VDT repotag to distinguish them from the ones that come from EPEL. We will also recommend using yum priorities to prefer the VDT versions. 

---+++ EMI

EMI 1.0 is very new. We expect to use many of their packages, but we will prefer to copy the packages to our repository instead of relying directly on the EMI repository. This will allow us to control the versions of the critical grid software our stakeholders need.

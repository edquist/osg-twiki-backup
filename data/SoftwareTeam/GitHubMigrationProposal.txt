%META:TOPICINFO{author="MatyasSelmeci" date="1456525343" format="1.1" reprev="1.9" version="1.9"}%
%META:TOPICPARENT{name="InternalDocs"}%
%TOC%

---+ Switching Software Area (/software) to !GitHub


This document details the plan for migrating the projects in the VDT SVN
software area to Git repositories located primarily on !GitHub.  This document
supersedes [[SoftwareTeam.GitMigrationProposal]].



---++ Repo characteristics


This plan involves creating two repositories per software project: a "GitHub
repository" and an "AFS repository". Their characteristics are as follows:

   * An AFS repository is the "one true copy" of the project repository.\
      It has the following properties:
      * If there is a conflict between an AFS repository and *any* other repository (including the !GitHub repository), the AFS repository "wins".
      * If the AFS repository goes offline or becomes inaccessible, it is considered a fire and should be fixed within two business days.

   * A !GitHub repository is the project repository that developers will use for their daily work.\
      It has the following properties:
      * It is easy to access and update (for authorized users).
      * Developers publish their changes to the !GitHub repository.
      * If the !GitHub repository goes offline or becomes inaccessible, it is considered a major hassle, but not a fire.
      * The AFS repository pulls data from the !GitHub repository.


---++ Objectives


   * The OSG (or CHTC) must own and fully manage the operations of the AFS Git repositories.
   * We must have dependable backups of the repositories.
   * Anyone should be able to submit a contribution.
   * The OSG Technology team must have sole write privileges on the AFS repositories.
   * Team members must be able to easily review and approve submitted contributions.
   * The workflows for both contributors and team members must be clearly documented.\
     Common use cases should be efficient and easy to learn.
   * The migration process must preserve existing data, should interrupt work little, and should be reversible.
   * The AFS repositories should be kept up-to-date with the !GitHub repositories.
   * Anyone should be able to read the !GitHub repositories, including histories.
   * We can do releases when the !GitHub repositories are down.


---++ High-Level Architecture


Developers use the !GitHub repos for day to day work, using the typical !GitHub
workflow: fork, commit, make pull requests. Repos are frequently synced to AFS
to create a backup in case something goes wrong.

---+++ AFS repos

The authoritative repos will be on the UW's AFS.  We'll use the UW CSL's
Kerberos for authentication and access control.  In the normal case, team
members do not touch or clone from the AFS repositories.  If a
!GitHub repo becomes unusable for some reason (outage, corruption, etc.),
trusted developers (i.e. those with the right AFS ACLs) will push directly to
the AFS repo until the problem is resolved.

---+++ !GitHub repos

The repos that developers use for day-to-day work will be on !GitHub.  They
will be owned by the "opensciencegrid" organization.  Team members will need to
have !GitHub accounts, and have write access granted via !GitHub's access
control mechanisms in order to approve contributions.  The !GitHub repos will
be configured to reject "unsafe" commits (commits that alter history, cause
conflicts, or otherwise cause breakage or potential loss of information).

---+++ Synchronization

Each AFS repo will periodically pull from the corresponding !GitHub repo.  The
properties of the AFS repo will be set so that it only accepts changes that are
"safe".

If an "unsafe" update is attempted, the developers will be notified via email.
They will have to resolve the conflict and push the changes back to !GitHub.

---+++ Backups

The AFS repos will live on an AFS volume that is backed up nightly by the CSL.
We will make a "snapshot" of the repo before each backup runs, to ensure
consistency.  This process is modeled after what we do for the VDT SVN repos.

---+++ Contributions

External collaborators or team members will fork one of the !GitHub repos and
submit their changes as pull requests; a team member will review and merge the
pull requests to incorporate the changes.


---++ Detailed Architecture


---+++ AFS repos

The AFS repo for a software project will live under
<code>/p/condor/workspaces/vdt/git/software/<em>PROJECT</em>.git</code>
Once the !GitHub repo for a project has been created, making the corresponding
AFS repo is as follows:
<pre>
PROJECT=&lt;your project&gt;

cd /p/condor/workspaces/vdt/git/software/
git clone --mirror https://github.com/opensciencegrid/$PROJECT.git
cd $PROJECT.git/

# Check integrity of each object fetched:
git config transfer.fsckObjects true

# Enable the reflog (helps debugging):
git config core.logAllRefUpdates true

# Only allow non-fast-forward updates for pull requests:
git config remote.origin.fetch '+refs/pull/*:refs/pull/*'
git config --add remote.origin.fetch 'refs/*:refs/*'

# Allow pushing only one branch/tag at a time back to GitHub.
# Pushing all branches/tags can be done by explicitly specifying
# --mirror to "git push"
git config --unset remote.origin.mirror
</pre>

The AFS ACLs for each repo will be copied from
<code>/p/condor/workspaces/vdt/git</code>.

---+++ !GitHub repos

The !GitHub repo for a project will be owned by the Open Science Grid !GitHub
organization (username "opensciencegrid"). The URI for the project will be:
<code>https://github.com/opensciencegrid/<em>PROJECT</em></code>

We will enable
[[https://help.github.com/articles/about-protected-branches/][protected branches]]
for all branches of the project, to prevent non-fast-forward pushes.

---++++ Access control

!GitHub repos have three kinds of permissions:

   $ Read: the ability to see the contents of the repository, fork the repo,
     and submit a pull request.
   $ Write: the ability to accept pull requests or push to the repository; implies read access.
   $ Admin: the ability to grant or revoke privileges, and the ability to make changes that affect the entire repo, such as transferring ownership, or deleting the repo; implies read and write access.

Read access is given to everyone, because !GitHub repos are public unless we
pay !GitHub money.

Write access will be given to the
[[https://github.com/orgs/opensciencegrid/teams/software][Software team]] and
the primary contributors of the software if they are not in the Software team.

Admin access will be given to the
[[https://github.com/orgs/opensciencegrid/teams/core][Core team]].

The
[[https://github.com/orgs/opensciencegrid/people?utf8=%E2%9C%93&query=role%3Aowner+][owners of the Open Science Grid organization]]
control team membership.

---+++ Synchronization

---++++ Fetcher cron job

   * There will be one "fetcher" cron job, owned by =cndrutil=, to download
     !GitHub repo changes to the AFS repos by running =git fetch= for each repo.
   * The cron job will run every 10 minutes.  This is often enough to keep the
     AFS repos in sync most of the time, but should avoid placing too much load
     on the machine doing the syncing.
   * Any nonzero exit codes will result in an email to Madison people.
   * The list of repos will be taken from a file called =/p/condor/workspaces/vdt/git/remotes.list=.
   * Results will be logged to =/p/condor/workspaces/vdt/git/backups.log=. The log will be rotated.
   * After a successful fetch, update a file called =fetchstats= containing:
      * the timestamp of the last successful fetch, in human-readable format
      * a count of the number of successful fetches
   * A team member can create a file named =NO_FETCH= in an AFS repo to disable
     fetches for that repo, in case there is a persistent error that needs manual
     intervention to solve.

---++++ Watchdog cron job

   * There will be one "watchdog" cron job that will run nightly to examine the AFS
     repos and send email to the Madison people about:
      * any =NO_FETCH= files
      * last update time for each repo (mismatches should be investigated)
      * number of successful fetches since last report (unexpectedly low numbers
        should be investigated)
   * After successfully sending an email, the watchdog should log the count of
     successful fetches from each =fetchstats= file, and reset that number to
     zero.

---+++ Nightly AFS Backups

A single cron job will go through each AFS repo dir <em>PROJECT</em>.git, and do this:

<pre>
PROJECT=&lt;your project&gt;

rm -rf "/p/condor/workspaces/git-backup/${PROJECT}.git.tmp"
git clone --mirror "/p/condor/workspaces/git/${PROJECT}.git" \
                   "/p/condor/workspaces/git-backup/${PROJECT}.git.tmp"
rm -rf "/p/condor/workspaces/git-backup/${PROJECT}.git"
mv "/p/condor/workspaces/git-backup/${PROJECT}.git.tmp" \
   "/p/condor/workspaces/git-backup/${PROJECT}.git"
</pre>

In the unlikely event of an AFS repo becoming unrepairable <em>and</em> we are
unable to make a new clone from !GitHub, this is how we restore:

<pre>
PROJECT=&lt;your project&gt;

rm -rf "/p/condor/workspaces/git/${PROJECT}.git"
git clone --mirror "/p/condor/workspaces/git-backup/${PROJECT}.git" \
                   "/p/condor/workspaces/git/${PROJECT}.git"
cd "/p/condor/workspaces/git/${PROJECT}.git"
# restore "config" from an AFS backup
</pre>

---++ Migration

---+++ One-time setup

   1. Create AFS volume for =/p/condor/workspaces/vdt/git= (done)
   1. Create authors file to map SVN user names to email addresses for Git
      (there is one at "/p/condor/workspaces/vdt/svn-access/authors.txt" --
      make sure it's up-to-date)
   1. Create "backup" cron job, run by =cndrutil= (see "Backups" section)
   1. Create "fetch" and "watchdog" cron jobs, run by =cndrutil= (see
      "Synchronization" section)

---+++ Per-project migration

One of the !GitHub migration owners (read: Main.MatyasSelmeci and
Main.CarlEdquist) will convert the project from SVN to Git.

Some projects already have read-only !GitHub mirrors. For example,
[[https://vdt.cs.wisc.edu/svn/software/osg-configure/][osg-configure in SVN]]
has a corresponding
[[https://github.com/opensciencegrid/osg-configure][osg-configure repo in !GitHub]].
There are special considerations for those projects.


Before doing any conversions, we must contact the software owners and major
contributors, and work with them to make sure the conversion has a minimal
impact on their work process.

The outcomes of the conversion that may affect their work are:

   * the corresponding SVN repo will become read-only
   * the !GitHub read-only mirror, if one exists, will have its history
     overwritten

*Contributors must commit their work to SVN before the conversion to avoid
problems.* If necessary, schedule a switchover date with the owners and major
contributors.


Overall steps are:

   1. Wait for the switchover date if necessary.
   1. If there is no read-only !GitHub mirror, create the !GitHub repo under
      the "opensciencegrid" organization.
   1. Do the conversion: create a new Git repo based on the data from SVN using
      the script
      [[https://vdt.cs.wisc.edu/svn/software/tools/git-svn-bare-setup][git-svn-bare-setup]]:\
<pre>
svn checkout https://vdt.cs.wisc.edu/svn/software/tools/

PROJECT=<em>PROJECT</em>
tools/git-svn-bare-setup $PROJECT
cd $PROJECT.git
</pre>
      1. Inspect the repo (eg, with <code>gitk --all</code>) and perform any manual tidying, if appropriate.
      1. Prune dead branches:\
<pre>
../tools/trim-deleted-svn-branches
</pre>
<!--
      1. Deal with dead branches (i.e. branches that are not present in the most recent SVN revision):
         1. If the branch has been fully merged into =trunk=, delete the branch:\
<pre>
git branch -d <em>BRANCH</em>
</pre>
         1. Else, tag the branch first, then delete it.
            The tag will be named after the branch and the last commit number in the branch.
            For example, if the branch =test= was last updated
            on SVN revision =12345=, then the tag would be called =test@12345=.
            Create the tag, then delete the branch:\
<pre>
BRANCH=<em>BRANCH</em>
SUFFIX=$(git show ${BRANCH} | grep git-svn-id | grep -Eo '@[[:digit:]]+')
git tag ${BRANCH}${SUFFIX} ${BRANCH}  &&  git branch -D ${BRANCH}
</pre>
-->
      1. Push all branches and tags.\
<pre>
git push github
</pre>
   1. Enable protected branches for the repo in !GitHub:
      1. In the !GitHub web interface for the repo, go to "Settings &rarr; Branches".
      1. Under "Protected branches", select a branch.
      1. Check "Protect this branch".
      1. Click "Save changes".
      1. Repeat for all the other branches.
   1. Edit !GitHub permissions on the repo:
      1. In the !GitHub web interface for the repo, go to "Settings &rarr; Collaborators &amp; teams".
      1. Ensure the team "Core" is added and has Admin privileges.
      1. Ensure the team "Software" is added and has Admin privileges.
      1. If the software owner is not on the Software team, add them to the
         "Collaborators" section and give them Write privileges.
   1. Add the repo to =/p/condor/workspaces/vdt/git/remotes.list=.
   1. Wait for the fetcher script to run.
   1. Make a file in the trunk of the SVN dir called =MOVED-TO-GIT= that
      contains the following text:<pre>
The source code for this project is now contained in GitHub at opensciencegrid/<b>PROJECT</b>
Changes committed to SVN will be ignored.</pre>
   1. =svn lock= the project in SVN.

%RED%If anything fails, either debug, _carefully recording all steps_ or just try
again.%ENDCOLOR%


---++ Safety

See the [[SoftwareTeam.GitHubMigrationProposalSafetyInvestigation][safety investigation]]
page for a report our investigations into the safety of this plan.

-- Main.MatyasSelmeci - 12 Feb 2016

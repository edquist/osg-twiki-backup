%META:TOPICINFO{author="JoseCaballero" date="1427652945" format="1.1" version="1.10"}%
%META:TOPICPARENT{name="InternalDocs"}%
%TOC{depth="3"}%

---+ Software Development Process

This page is for the OSG Software team and other contributors to the OSG software stack. It is meant to be the central source for all development processes for the Software team. (But right now, it is just a starting point.)


---++ Overall Development Cycle

For a typical update to an existing package, the overall development cycle is roughly as follows:

   1. Download the new upstream source (tarball, source RPM, checkout) into [[RPMDevelopmentGuide#Upstream_Source_Cache][the UW AFS upstream area]]
   1. In [[RPMDevelopmentGuide#Revision_Control_System][a checkout of our packaging code]], update [[RPMDevelopmentGuide#upstream][the reference to the upstream file]] and, as needed, [[RPMDevelopmentGuide#osg][the RPM spec file]]
   1. Use [[OSGBuildTools#osg_build][osg-build]] to perform a scratch build of the updated package
   1. Verify that the build succeeded; if not, redo previous steps until success
   1. Optionally, lightly test the new RPM(s); if there are problems, redo previous steps until success
   1. Use [[OSGBuildTools#osg_build][osg-build]] to perform an official build of the updated package (which will go into the development repos)
   1. Perform standard developer testing of the new RPM(s) — see below for details
   1. Obtain permission from the Software manager to promote the package
   1. Promote the package to testing — see below for details


---++ Build Procedures

---+++ Building packages for multiple OSG release series

The OSG Software team supports multiple release series, independent but in parallel to a large degree. In many cases, a single package is the same across release series, and therefore we want to build the package once and share it among the series. The procedure below suggests a way to accomplish this task. Currently, *maintenance* refers to OSG 3.1, and *current* refers to OSG 3.2 ( *trunk* ).

   1. Make changes to the *trunk*
   1. Optionally, make and test a scratch build from the *trunk*
   1. Commit the changes
   1. Make an official build from the *trunk* (e.g.: <code>osg-build koji <em>PACKAGE</em></code>)
   1. Perform the standard 4 tests for the *current* series (see below)
   1. Merge the relevant commits from the *trunk* into the *maintenance* branch (see below for tips)
   1. Optionally, make and test a scratch build from the *maintenance* branch
   1. Commit the merge
   1. Make an official build from the *maintenance* branch (e.g.: <code>osg-build koji --repo=3.1 <em>PACKAGE</em></code>)
   1. Perform the standard 4 tests for the *maintenance* series (see below)
   1. As needed (or directed by the Software manager), perform the cross-series tests (see below)

*Note:* Do not change the RPM Release number in the *maintenance* branch before rebuilding; the %dist tag will differ automatically, and hence the *maintenance* and *current* !NVRs will not conflict.

---+++ Merging changes from one release series to another

These instructions assume that you are merging from =trunk= to =branches/osg-3.1=.
They also assume that the current directory you are in is a checkout of =branches/osg-3.1=.
I will use =$pkg= to refer to the name of your package.

First, you will need the commit numbers for your changes:
<pre>svn log \^/native/redhat/trunk/$pkg | less</pre>
Write down the commits you want to merge.

If you only have one commit, merge that commit with -c as follows:
<pre>svn merge -c $commit_num \^/native/redhat/trunk/$pkg $pkg</pre>
Where =$commit_num= is the SVN revision number of that commit (e.g. 17000).
Merging an individual change like this is referred to as "cherry-picking".

If you have a range of commits and you wish to merge all commits within that range, then do the following:
<pre>svn merge -r $start_num:$end_num \^/native/redhat/trunk/$pkg $pkg</pre>
Where =$start_num= is the SVN revision of the commit _BEFORE_ your first commit, and =$end_num= is the SVN revision of your last commit in that range.
*Note:* Be very careful when merging a range from trunk into the maintenance branch so that you do not introduce more changes to the maintenance branch than are necessary.

If you have multiple commits but they are not contiguous (i.e. there are commits made by you or someone else in that range that you do not want to merge),you will need to cherry-pick each individual commit.
<pre>svn merge -c $commit1 \^/native/redhat/trunk/$pkg $pkg
svn merge -c $commit2 \^/native/redhat/trunk/$pkg $pkg
...</pre>
Where =$commit1=, =$commit2= are the commit numbers of the individual changes.

Note that merge tracking in recent versions of SVN (1.5 or newer) should prevent commits from accidentally being merged multiple times.
You should still look out for conflicts and examine the changes via =svn diff= before committing the merge.

#TestingProcedures
---++ Testing Procedures

Before promoting a package to a testing repository, each build must be tested lightly from the development repos to make sure that it is not completely broken, thereby wasting time during acceptance testing. Normally, the person who builds a package performs the development testing.

<span style="color: #F60;">If you are not doing your own development testing for a package,</span> contact the Software Manager and/or leave a comment in the associated ticket; otherwise, your package may never be promoted to testing and hence never released.

---+++ The “Standard 4” tests, defined

In most cases, the Software manager will ask a developer to perform the “standard 4” tests on an updated package in a release series before promotion. This is a shorthand description for a standard set of 4 test runs:

   * Fresh install on el5
   * Fresh install on el6
   * Update install on el5
   * Update install on el6

An “update install” is a fresh install of the relevant package (or better yet, metapackage that includes it) *from the production repository*, followed by an update to the new build *from the development repository*.

For each test run, the amount of functional testing required will vary.

   * For very simple changes, it may be sufficient to verify that each installation succeeds and that the expected files are in place
   * For some changes, it may be sufficient to run osg-test on the resultant installation
   * For some changes, it will be necessary to perform careful functional tests of the affected component(s)

If you have questions, check with the Software Manager to determine the amount of testing that is required per test run.

---+++ The “Cross-Series” tests, defined

The cross-series tests may need to be run for packages that have been built for multiple release series of the OSG software stack (currently 3.1 and 3.2):

   * On el5, install from the 3.1 repositories, then update from the 3.2 repositories
   * On el6, install from the 3.1 repositories, then update from the 3.2 repositories

Viewed another way, these tests are similar to the update installs, above, except from 3.1-development to 3.2-development.

---+++ The “Standard 10” tests, defined

This is just the standard 4 for the maintenance branch (3.1), plus the standard 4 for the current branch (3.2), plus the cross-series 2.

---+++ Running the tests in VM Universe

In the case that the package you're testing is covered by osg-tested-internal, you can run the standard 10 tests in a manual VM universe test run. Make sure you meet the [[SoftwareTeam.TestRunsAsVMs][pre-requisites]] required to submit VM Universe jobs on =osghost.ctc.wisc.edu=. After that's done, you can prepare the test suite by running:

<pre class="screen">
osg-run-tests 'Testing &lt;change x&gt;'
</pre>

After you =cd= into the directory specified in the output of the previous command, you will need to edit =test-parameters.yaml= to reflect the tests that you will want to run i.e. clean installs, upgrade installs and upgrade installs between OSG versions. 

%TWISTY{%TWISTY_OPTS_OUTPUT% showlink="Click to expand an example test-parameters.yaml"}%
<pre class="file">
platform:
  - centos_5_x86_64
  - centos_6_x86_64
  - rhel_5_x86_64
  - rhel_6_x86_64
  - sl_5_x86_64
  - sl_6_x86_64

sources:
  - 3.1; osg-development                       # Tests clean installs of 3.1 development
  - 3.1; osg > osg-development                 # Tests update installs of 3.1 development
  - 3.2; osg-development                       # Tests clean installs of 3.2 development
  - 3.2; osg > osg-development                 # Tests update installs of 3.2 development
  - 3.1; osg > 3.2/osg-development             # Tests update installs between 3.1 and 3.2 development
  - 3.1; osg-development > 3.2/osg-development # Tests update installs between 3.1 developemtn and 3.2 development

packages:
  - [osg-tested-internal]
</pre>
%ENDTWISTY%

Once you're satisfied with your list of parameters, submit the dag:

<pre class="rootscreen">
condor_submit_dag master-run.dag
</pre>

---++ Promoting a Package to Testing

Once development testing is complete, follow these steps:

   1. Make sure the package update has at least one associated JIRA ticket; if there is no ticket, at least create one for releasing the package(s)
   1. Obtain permission to promote the package(s) from the Software manager; you will likely be asked about the associated ticket(s) and development testing
   1. Use [[OSGBuildTools#osg_promote][osg-promote]] to promote the package(s) from development to testing\
      <p>Note that if you built your package for both the maintenance branch (3.1) and the current branch (3.2) then you will need to individually promote both sets of builds.</p>
   1. Add a comment to the associated JIRA ticket(s) with the NVR of the build(s) and, if you know, suggestions for acceptance testing
   1. Mark each associated JIRA ticket as “Ready For Testing” and set the Assignee to “Unassigned”
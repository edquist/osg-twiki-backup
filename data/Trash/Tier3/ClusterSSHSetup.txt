%META:TOPICINFO{author="KyleGross" date="1329928281" format="1.1" version="1.13"}%
%META:TOPICPARENT{name="Tier3DocDev"}%
---+!! *<nop>%SPACEOUT{ "%TOPIC%" }%*
%DOC_STATUS_TABLE%
%TOC{depth="2"}%

---++ Introduction
   * To make our cluster secure we'll use a host-based SSH key infrastructure.
   * Here we want to setup host authentication for the root account such that:
      * SSH for the root user on the management node to access each of the other nodes on the cluster
      * SSH for the root user works without complaint between all head nodes on the cluster
      * SSH for the root user works without complaint between the head nodes and compute nodes on the cluster                                                                         
   * We use host-based ssh for root logins and pubkey-based ssh for user logins.  Either or both of these can be enabled separately depending on the desired site policy. 

%DISCLAIMER% The configuration described here is suggestive of what could be done for a test cluster and depicts one approach to handling access by root and user accounts.  Many universities or laboratories will have specific policies in place as to which types of access is permitted with varying degrees of restrictiveness depending on the desired security level. 

---+++ Help
Since this is a local cluster configuration, get help from local site sysadmins. Another way of getting hands on support is to attend the [[SiteCoordination.ChatCalendar][OSG campfire chat sessions]].

---++ Set configuration in sshd_config 

All hosts should have the following lines in their =/etc/ssh/sshd_config= file. This is a recommended setup, keep in mind the disclaimer above: 
<pre class="screen">
Protocol 2

# No passwords
PermitRootLogin without-password
PasswordAuthentication no
PermitEmptyPasswords no
UsePAM no

# Pub keys configuration
RSAAuthentication yes
DSAAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
KerberosAuthentication no
GSSAPIAuthentication no
GSSAPICleanupCredentials no

# Hostbased and pubkey yes
PubkeyAuthentication yes
ChallengeResponseAuthentication no
X11Forwarding no

# Hostbased
HostbasedAuthentication yes
IgnoreRhosts no

#OPTIONALLY DON'T CHECK gethostbyaddr(), TRUST CLIENT
#HostbasedUsesNameFromPacketOnly yes
</pre>


---++ Host-based access for root:
 
For host-based authentication, all hosts must have a valid host key for all the other hosts in the cluster. The =ssh-keyscan= utility can be used to construct the =ssh_known_hosts= file, but you need to provide a list of hostnames.

   * Here's a way you can use =/etc/hosts= to generate this list:<pre class="screen">
 ssh-keyscan -t rsa,dsa `grep -v \# /etc/hosts` > ssh_known_hosts
</pre>
This just removes comment lines from the /etc/hosts file, which
confuse =ssh-keyscan=.  Any hosts in /etc/hosts which are not found
will result in an error message, but this will go to stderr not 
stdout so anything written to the output file ssh_known_hosts is OK.  
   * Then you copy this file to =/etc/ssh/ssh_known_hosts=.
   * Copy this file into =/etc/ssh/ssh_known_hosts= on each host in the cluster
   * You also need to list the hosts in =/root/.shosts=, without the keys.  You can construct
this file by hand, or from the =/etc/hosts= file, or from the =ssh_known_hosts= file we just created:<pre class="screen">
cut -d' ' -f1 < /etc/ssh/ssh_known_hosts|sort -u | grep -v ,  > /root/.shosts
</pre> *This =/root/.shosts= file must be present on all target machines.*
   * Now all root logins should work across the cluster from the head nodes.

---+++ Group of hosts with regular names
If the hosts have a regular naming scheme, you can use a for-loop instead of the /etc/hosts file:
   *  eg. if they are <tt>host01,host02,....host08</tt>, then in bash you can do:
<pre class="screen">
 for x in {1..8} ; do
    hostname=$(printf host%02d $x)
    ssh-keyscan -t dsa,rsa $hostname
 done
</pre>

---+++ Adding new hosts
If there are some hosts that got missed, or new hosts added, you can do:
<pre class="screen">
 ssh-keyscan -t rsa,dsa <i>HOSTNAME</i>
</pre>
for the new host or hosts, and append that to the =ssh_known_hosts=

---+++ Multiple host names
Also note that if you access the host via multiple names - e.g.
=uct2-c001, uct2-c001.mwt2.org= and =uct2-c001.uchicago.edu=, you
have to have records in ssh_known_hosts for each of the hostnames.
In this case, you would do:

<pre class="screen">
 ssh-keyscan -t rsa,dsa uct2-c001 uct2-c001.mwt2.org uct2-c001.uchicago.edu
</pre>

---+++ Changes to host names
If hosts are changed or replaced, or their ssh host key changes,
the corresponding entry in =/etc/ssh/ssh_known_hosts= must be updated.




---++ Pubkey-based access for non-root users

Simply add the user's ssh pubkey into =$HOME/.ssh/authorized_keys=
This file must not be group- or world- readable (mode 600) and the directory
=$HOME/.ssh= must be mode 700 (drwx------)


---++ Authentication for users
The following is an easy way to add ssh key authentication for a (non root) user on all nodes that share the same home directory exported by =gc1-nfs=. It also makes sure that permissions are correct.

   * The user should login to your user account on the user interface machine (*gc1-ui*):
   * In the home directory of your account, do: <pre class="screen">cd ~/.ssh/
ssh-keygen -t dsa
# respond enter to use the default key name and enter the same passphrase twice 
# (make sure to enter the same passphrase)
# this will generate id_dsa and id_dsa.pub files 
cat id_dsa.pub >> authorized_keys
chmod 600 authorized_keys           
chmod 600 id_dsa
chmod 700 ~/.ssh
</pre>


   * You can also use ssh-agent from a client machine where your private key is stored (see below).

---++ Use of SSH Agent
To avoid typing continuously password or passphrase you can use ssh-agents and agent forwarding.
SSH-agent is a program that can store your certificates and private keys during a session and present them for authentication when needed.

=ssh-agent= initiates a session and will return environment settings about it:<pre class="screen">
ssh-agent
SSH_AUTH_SOCK=/tmp/ssh-JIFzY26048/agent.26048; export SSH_AUTH_SOCK;
SSH_AGENT_PID=26049; export SSH_AGENT_PID;
echo Agent pid 26049;
</pre>
New shells on the same host can use the agent once the environment is set.

Other useful commands:
   * =ssh-add <key_file>= adds keys to the session
   * =ssh-add -l= lists keys
   * =ssh-add -L= more detailed list of keys
   * =ssh-add -d <key_file>= removes the key from the session
   * =ssh-add -D= removes all the keys from the repository

With the correct settings in the configuration<verbatim>
Host <hostname or *>
    ForwardAgent yes
</verbatim>
or =ssh -A ...=, users can force the forwarding of the keys so that remote ssh sessions have all the keys that are in the source session.

[[http://www.securityfocus.com/infocus/1812][Here]] is more information on SSH and agents and [[http://unixwiz.net/techtips/ssh-agent-forwarding.html][here]] is an illustrated guide on SSH agents and agent forwarding.

---++ Service Configuration/Startup/Shutdown
After making configuration changes SSH can be restarted by typing
<pre class="screen">/etc/init.d/sshd restart</pre>

---++ Validation of Service Operation
Test by logging in to another SSH site on the network.

---++ Debugging Information
Logs for Scientific Linux 5 can be found in two system logfiles:
   * =/var/log/secure=
   * =/var/log/messages=
The SSH configuration file is located in: 
   * =/etc/ssh/sshd_config=

---++ Comments
%COMMENT{type="tableappend"}%

%BR%
%COMPLETE3% %BR%
%RESPONSIBLE% Main.MarcoMambelli - 23 Nov 2009 %BR%
%REVIEW%

<!-- CONTENT MANAGEMENT PROJECT
############################################################################################################ 
   DEAR DOCUMENT OWNER
   ===================

   Thank you for claiming ownership for this document! Please fill in your FirstLast name here:
   * Local OWNER          = MarcoMambelli

   Please define the document area, choose one of the defined areas from the next line
   DOC_AREA = (ComputeElement|Storage|VO|Security|User|Monitoring|General|Integration|Operations|Tier3)
   * Local DOC_AREA       =  Tier3

   define the primary role the document serves, choose one of the defined roles from the next line
   DOC_ROLE = (EndUser|Student|Developer|SysAdmin|VOManager|Documenter)
   * Local DOC_ROLE       = SysAdmin

   Please define the document type, choose one of the defined types from the next line
   DOC_TYPE = (Troubleshooting|Training|Installation|HowTo|Planning|Navigation|Knowledge)
   * Local DOC_TYPE       = Installation
   
   Please define if this document in general needs to be reviewed before release ( %YES% | %NO% )
   * Local INCLUDE_REVIEW = %NO%

   Please define if this document in general needs to be tested before release ( %YES% | %NO% )
   * Local INCLUDE_TEST   = %NO%

   change to %YES% once the document is ready to be reviewed and back to %NO% if that is not the case
   * Local REVIEW_READY   = %YES%

   change to %YES% once the document is ready to be tested and back to %NO% if that is not the case
   * Local TEST_READY     = %NO%

   change to %YES% only if the document has passed the review and the test (if applicable) and is ready for release
   reviewed during DOC workshop
   * Local RELEASE_READY  = %YES%


   DEAR DOCUMENT REVIEWER
   ======================

   Thank for reviewing this document! Please fill in your FirstLast name here:
   * Local REVIEWER       = DocWorkshop
  
   Please define the review status for this document to be in progress ( %IN_PROGRESS% ), failed ( %NO% ) or passed ( %YES% )
   * Local REVIEW_PASSED  = %YES%


   DEAR DOCUMENT TESTER
   ====================

   Thank for testing this document! Please fill in your FirstLast name here:
   * Local TESTER         = 
  
   Please define the test status for this document to be in progress ( %IN_PROGRESS% ), failed ( %NO% ) or passed ( %YES% )
   * Local TEST_PASSED    = %IN_PROGRESS%
############################################################################################################ 
-->
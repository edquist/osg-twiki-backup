%META:TOPICINFO{author="AnandPadmanabhan" date="1222622648" format="1.1" version="1.14"}%
%META:TOPICPARENT{name="SecurityTeamWorkingArea"}%
---++ COMMAND LINE SECURITY TOOLS MANAGEMENT PLAN

%TOC%

This is the plan for implementing a CA management tool. The tool interface is copied below:
Purpose: This script shall show the accepted CAs, check and renew the CRLs, add and remove CAs from the list of accepted CAs.

%BLUE% From -- Main.DougOlson - 17 Sep 2008

Maybe listing a few design goals is useful. Such as:
   * It would be good to minimize or eliminate dependencies on other middleware
   * installation and management of the trusted CAs (or we could say Trust Fabric) should be the same process for any subsequent software
   * since there are many use cases of having multiple instances of some $VDT_LOCATION installed on a host we should consider making installation of the Trust Fabric a separate step and prerequisite to other software installations
   * this tool should be coordinated with the automated procedures for maintaining CA files, vdt-update-certs, yum (obvious, I know but ... )
%ENDCOLOR%
 

---+++ ca_manage Options:

   * --dir <path of the CA repository> This takes the CA directory path as an input. Default: $X509_CERT_DIR, resp. 
/etc/grid-security/certificates

--showDir, complements the above option. It shows whatever the CA directory is set to.  

   * --distribution <URL>: sets location from where the CA files will be downloaded from. 
showDistribution. This will print out which ever location is being used in the config file

   * --listCA <pattern>: lists all currently accepted CAs, whose DN (CA’s own DN, or end user DN patterns?) match the pattern. All CAs are listed if no pattern is given. 
The outputs are: Which CA distribution service is used to install this CA list, when it is installed, The CAs’ name, their hash value, whether a CA is IGTF or TeraGrid accredited. The format of the pattern needs to be defined (regex?). –verbose 

Note if the configuration file is changed after the installation, no longer you will know which CA distribution service was used to download. You can create a log file for the ca_mgmt tool such that when it runs the vdt-cert-update script to install a new package, it writes an entry into the log file. 

Can we use vdt-status-update script for this option?

   * --checkCRL <CAhash or pattern>: prints out the last time the CRLs was updated. I added the CA name option because you should be able to see for a particular CA if you have updated its CRL or not. Imagine if a CA revoked bunch of people due to an incident, you like to ensure that CRL for that CA is updated. 
Prints out two dates: one CA created the CRL and the date the CRL is actually downloaded. 

We decided to get rid of this  and combine with verifyCA below. 

   * --fetchCRL <CAhash or pattern>: When no input specified, it retrieves CRL files for all CA within the directory. The crl_url file should have the CRL location to be fetched. When input is defined, it only retrieves the CRL for that CA.

   * --fetchCRL <CA hash or pattern> --force: it forces to download the CRL file from the CA. Normally if there is no update in CRL, fetchCRL would not download it. This command forces the download.   

   * --refreshCAPackage: It updates the CA directory: checks the new package, if there is anew distribution, it retrieves the CA certificates, CRL location files, signing policies. This command replaces the old files with newly retrieved files. When a file cannot be retrieved, the old one (if existing) is not updated. A warning message is printed. Currently, this command should go to VDT caches and download the CA package. 

   * refreshCAPackage –force. It downloads the CA package whether or not there is a new CA package distribution

   * --add <XYZ>: add the CA. XYZ are the filenames of the corresponding CAs/CRLs or the URL from where the CA files are being fetched. If more files are added, then the command –add is given multiple times. 

It will take two arguments: add <CA hash or pattern> <filePath to CA files>

We agreed to have XYZ as the file location on the disk. XYZ is not a URL because we are not sure if all CAs publish their files in a uniform format over the www. We will assume the site admin copied CA files on disk . 

   * --remove <CAhash or patterns>: It removes all files associated the specified CA. The files should be moved into a dedicated directory, from where they can easily be restored again. By default this should also remove all descendent certificates or the removed certificate. 

First give a warning. We decided not to remove subordinate CAs when removing a root CA. So the last line above is no longer valid. 

Explicit warning. This should give explicit warnings. When a root CA is removed, warning should list any subordinate CAs in the CA directory. Because subordinate CAs may be kept in the directory, they do not have to be removed as well. Imagine the case root CA is removed and updated with different files. We will still need subordinate CAs. 

   * --refreshCA <CAName><URL>: this command updates the CA files: CA certificates, signing policy, info and CRL location files. Unlike refreshCAPackage, this command only refreshes a specific CA. The second input URL tells where to pick up the files for that CA. When a root CA is updated, the effects on the subordinate CAs must also be evaluated. The output should list which subordinate CAs became invalid and needed updates. If possible, the subordinate CAs must also be updated with this command. 

Do not know how to implement because  ca does not distr .
At the meeting we decided not to implement this. However, it is possible to implement this against the GOC or VDT CA distribution service. Instead of installoing the entire CA tarball, only the specified CA files are copied from the GOC or VDT service (based on the second input to the command. ) 

   * --show <CAcert>: outputs detailed about the certificate, similar or identical to the ‘openssl x509’ command. 

   * --showChain <CA cert>: outputs the trust chain of the certificate; used together with show. I think it would be useful if we can pass end user certs as input to this command. 

   * --verifyCAs: this command will verify all CAs presented in the directory of “--dir”  and their corresponding CRL files. This command checks if a CA cert is expired; and whether CRL is expired. 

Verbose output can include the numbers of verified CAs and list of CAs.

We decided to combine checkCRL and verify CA and turn this into a checkCA option

checkCA <CA hash or pattern> when no input is given the command runs for all CAs. 
It prints out: whether the CA cert is expired, the date the CA cert is downloaded, the date CA cert will be expired. whether CRL is expired. The date the CRL is downloaded and the date the CRL file actually created (by the CA), the date the CRL file will be expired. 

We can implement this with verbose option. In that case, without verbose we can print out whether CA file and CRL file is expired or not. The remaining outputs are printed when –verbose is set.   

   * diffCAPackage. This command checks the distribution package from GOC or VDT against the CA directory on disk. It lists all differences between the CAs on disk and the CAs included in the distribution at GOC or VDT (the config file tells us which distribution service is used by the user; therefore it runs diff against only one of these services.) 
By difference we mean, the CA files different on the CA package and on file. 

   * Rpm –q whatprovides
 it would be good if the script did  rpm -qf  first to check if the files are owned by an RPM and issue a warning. People looking at systems with YUM set up to fetch new CA files automatically should be fixing that if it goes wrong, rather than doing stuff manually.

Installed on: all hosts, where the CA repository is installed. 
Note: 

   1.	A newly added/removed CA must be handled properly when updating the CA repository.
   2.	Race conditions during updates must be handled properly.
  

---+++ CA MANAGEMENT  TOOL SPECIFICATION (Anand 9/23)

---++++ Syntax:
<verbatim>
ca_manage [global_options] command 
</verbatim>
%GREEN%(AR) Since we ship this with the VDT, should it be vdt-ca-manage?%ENDCOLOR%
%RED%(AP) Agreed. %ENDCOLOR%
<verbatim>
global_options =
 [--vdt-location <location>]
 [--verbose]
 [--force]
 [--certDir <location>]
</verbatim>
%GREEN%(AR) We need a --help option. Probably a --version option as well.%ENDCOLOR%
%RED%(AP) Agreed. %ENDCOLOR%

%RED%(AP) May be an --autorefresh & --norefresh option (to refresh CA and CRL or not)  will be useful to proceed without having to prompt.%ENDCOLOR%
<verbatim>
command = [manage_command | status_command]  [<command_options>]

status_command = [
 showDistributionURL |
 listCA [--dir <local_dir>] [--pattern <pattern>] |
 verify [--hash <CA_hash>] |
 diffCAPackage |
 show [--certfile <cert_file> | --hash <CA_hash>] |
 showChain [--certfile <cert_file> | --hash <CA_hash>]
]

manage_command = [
 refreshCAPackage |
 fetchCRL |
 setDistributionURL [--url <URL_location>] |
 add [--dir <local_dir>] --hash <CA_hash> |
 remove --hash <CA_hash>
]


</verbatim>
---++++ Explanation of global options

Zero or more of these options may be used during an execution of ca_manage. 

   1.	<verbatim>--vdt-location <location></verbatim> The location the VDT was installed in. This option overrides the $VDT_LOCATION environment variable if it exists. This option is not needed if $VDT_LOCATION is set to the correct location. 
   2. <verbatim>--verbose</verbatim> Provides you with more information depending on the command context.
   3.	<verbatim>--force</verbatim> Forces the command to run ignoring any checks/warnings. The actual effect is context depended, and this behavior is noted in the command details below.
   4.	<verbatim>--certDir <location></verbatim> This location specifies the path CA directory. If this option is not specified then the command will look for $X509_CERT_DIR, $VDT_LOCATION/globus/TRUSTED_CA, and /etc/grid-security/certificates, respectively. If none of these directories can be found, the command will exit with an error.
 *NOTE:* I don't agree with the –showDir option in original specification, since providing a --showDir will require the ca_manage command to to tied with a single directory, thereby restricting the flexibility for the tool (for e.g. Managing the CE and the WN cert directories). 

%BLUE%(MA) Agreed%ENDCOLOR%
---++++ Explanation of commands

Exactly one command is to be specified during an execution of ca_manage

---+++++ Status_commands
   1.	<verbatim>showDistributionURL</verbatim> This will print out the distribution location specified in the config file. This command will read  vdt-update-certs.conf and output cacerts_url.%GREEN%(AR) This is a really long name to remember. Can we make it shorter??%ENDCOLOR% %RED%(AP) How about showCAURL and setCAURL? %ENDCOLOR%
   2.	<verbatim>listCA [--dir <local_dir>] [--pattern <pattern>]</verbatim> This command will use openssl x509 command on the files in the --dir to provide hash, the subject and whether a CA is IGTF or TeraGrid accredited (finding accreditation might require referring to some sort of static list). %BLUE%(MA) I would really like to output which method and distribution package are used to download CAs into the directory. %RED%(AP) I am a bit unclear of what Mine's request is. The showDistributionURL should tell you the package you are downloading and currently vdt-update-certs does not allow more than one CA package (we allow admins to add local CAs but there is no way for us to tell where they got the CA files from). Further vdt-version tells you what version of the CA you have by reading in vdt/etc/vdt-version.db. %ENDCOLOR% This is not too easy because it would require logging information, but very useful for site admin. Imagine that a site admin download a goc pacman package and then a new admin overwrites the config file with VDT location but does not download anything. %ENDCOLOR% %RED% (AP) I think we should leave it to vdt-cert-update to tell us what the cacert_url was when the packages were last downloaded. %ENDCOLOR% %RED% (AP) We could modify vdt-update-certs to record what package was used the last time the files where downloaded, which certs came from that package and which certs came from a local directory. Mine, Is this what you are looking for?%ENDCOLOR%  %BLUE% (MA) yes that was what I was looking for %ENDCOLOR%--verbose option will provide additional information like issuer %BLUE% (MA) issuer of the CA? %ENDCOLOR% %RED% (AP) Yes! Using the issuer field of the cert. %ENDCOLOR%  and associated dates %BLUE% (MA) can we please be specific here. is it CA cert issuance date, and CRL issuance date, or expiry dates, or all of them. I of course prefer all %ENDCOLOR% %RED% (AP) I was also implying all. %ENDCOLOR% %BLUE% (MA) great %ENDCOLOR%. If left unspecified --dir is is assumed to be same as --certDir. %BLUE%(MA) I thought --certDir is just an option, it does not set a environment variable , does it? %ENDCOLOR%  %RED% (AP) --certDir is not an environment variable, but there is a well defined order of how it will get resolved the option is not specified. I was stating that --dir will also follow the same resolution pattern. But thinking about it further I would say we could drop that --dir option in this command, since it is redundant and the user can achieve the same effect using the --certDIr. So the new new commnad would be listCA  [--pattern \<pattern\>].%ENDCOLOR% The \<pattern\> specified in the option will be matched, using perl regex, against the subject field of the certificate (but we can also expand it include issuer if needed) and all CAs are listed if no pattern is given.%BLUE% (MA) Agreed %ENDCOLOR%
%GREEN%(AR) Since we ship this with the VDT, should it be vdt-ca-manage?%ENDCOLOR%
   3.	<verbatim>verify [--hash <CA_hash>]</verbatim>  The verify command will check all CAs (or if specified only the \<CA_hash\>) in the \<certDir\> directory, to see if any CA/CRL have expired or are about to do so. If any expired CA/CRL are found, an error is issued along with the hash, date when CA cert/CRL expired. A warning is issued if either the CA cert or CRL is about the expire within the next 24 Hrs. The --verbose option provides a date the CA certs and CRL files are created (by the CA), downloaded (by VDT), and will expire. This will require a change in the vdt-update-certs to record the last time when the certs were downloaded.
%GREEN%(AR) Can we also print the CA's name?%ENDCOLOR%
%RED%(AP) Agreed. %ENDCOLOR%
%BLUE% (MA) Can this command take \<pattern\> as an input in addition to the hash value? %RED%(AP) I can, but like I noted later in add/remove, I would like the admin to unambiguously know which cert he is dealing with and can always find hash from pattern using listCA command. Though verify does not make changes as add/remove, I would prefer to keep a uniform interface. %ENDCOLOR% Also can we print the CA name in the output %RED%(AP) Agreed. %ENDCOLOR% %ENDCOLOR%%BLUE% (MA) well I am not sure if hash es are easy for the site amdins. But they can learn that from listCA command. I would prefer the pattern, but I am not super keen on it.%ENDCOLOR% 
   4.	<verbatim>diffCAPackage</verbatim> The specification says that this command checks the distribution package from GOC or VDT against the CA directory on disk. I am currently taking it to mean that we will check the files in the directory against what VDT downloaded during the last update. This will involve updating vdt-update-certs to record the certs it downloaded during the last update along with the md5 sums of the certs. If any new certs are found or any of the existing are found to be different, these will be identified and a warning will be issues. *NOTE:* If this command  was intended to download a new copy from VDT/OSG cache to check it against the local copy,  why not just replace old copy with the new one, since the copy coming from the cache is authoritative. %BLUE% (MA) This command compares the files inside the certDir against the files included in a CA distribution package. I would be careful to compare the files on disk against what VDT has downloaded during last update because the VDT download may not have gotten all the files or completely succeeded. Imagine the VDT update command loses a network packet in the middle or could not download a file. Thus, I would compare the files on disk against the real distribution package , not what VDT succeeded in downloading %ENDCOLOR% %RED%(AP) We will be using the same procedure VDT uses to download these certs, so using your example it equally likely that we might get a corrupted package. So, I think it will be wise to do the check in association with the script which downloaded the files in the first place. I am still unclear as to what this tool is intended to accomplish. If verify can run successfully then what ever cert files are in the directory are still valid. Now in order to do the diff against the latest version in the cache, you will need to download the current package from the VDT/OSG cache. At this stage what is advantage of doing the diff, rather than replacing the copy you have with the latest one you downloaded (assuming the package is correctly downloaded). The point I am trying to make is, comparing against the cache does not seem to provide useful functionality, since if there is a difference then you are supposed to run refreshCAPackage so that you are synced up. %ENDCOLOR% %RED% (AP) I would recommend dropping this command or making the diff or current directory against what VDT downloaded on the last execution. %ENDCOLOR% %BLUE% (MA) Anand, I like this command because system admins can make several changes to their existing directory and they would like to just see over the time what changes have been made. Imagine a new sys admin trying to learn what differences previous admin has made. The site policy may be different than our distribution cache. So site admin does not necessarily run the vdt-cert-update but ony see the differences. %ENDCOLOR%
   5.	<verbatim>show [--certfile <cert_file> | --hash <CA_hash>]</verbatim> This command will essentially provide a condensed output of openssl x509 command. --verbose option will provide the full output. If --hash option is used we will look for the \<CA_hash\>.o file in the \<certDir\>. 
   6.	<verbatim>showChain [--certfile <cert_file> | --hash <CA_hash>]</verbatim> This command will output the trust chain of the certificate. \<certDir\> will be used as the directory in which search for ancestor certs will be conducted. %BLUE% (MA) yes looking inside the certDir is the right approach %ENDCOLOR%

---+++++ Manage_commands
   1.	<verbatim>refreshCAPackage</verbatim> This command will refresh the CA package. It checks to see if a newer CA package is available and if so downloads it. If it is unsuccessfully in retrieving the newer package the existing one is left in place %BLUE% (MA) This means if the command does not succeed, there will be no changes to the certDir? %ENDCOLOR%. This option will use the existing vdt-update-certs –force to force a check for new CA package. The refreshCAPackage command can also be itself executed with a --force option. This would not only force a check but it will force a new download of certs irrespective of whether a new distribution package is available. This will require implementing a new option to vdt-update-certs to force downloads. (NOTE: I have some reservation providing an option that would ignore checks in vdt-update-certs) %GREEN%(AR) Does it update CRLs? Or should this go into vdt-update-certs? %ENDCOLOR%
   %BLUE% (MA) Answer to AR. I think this command should prompt user to run fetchCRL upon completion (automatically running fetchCRL-- that I am not so keen on). %RED%(AP) Agreed! The only point is we may want to give the user additional option to suppress the prompt and to define the default behavior (i.e. run automatically fetch-crl or not when prompt is supressed). --autorefresh and --norefresh proposed. %ENDCOLOR% I find it unlikely that if a site admin is refreshing his package, he would not want to grab the CRLs. Imagine that the crl_url file inside the package has been changed. The site admin would like to get the new CRL after the refresh. %ENDCOLOR%
   %BLUE% (MA) Can we input a single CA hash or its pattern as an input? It may be possible that an admin needs to refresh files regarding a single CA and does not want to refresh all other CAs?  %RED%(AP) I believe we agreed at the FNAL meeting that we won't be providing an option to update a single CA, since CA packages are not being distributed individually. %ENDCOLOR%
%BLUE% (MA) I do not remember if we agreed at FNAL, but OK for now.%ENDCOLOR%
Another question: refreshCAPackage --force would follow the configurations specified in the vdt-update-certs.config file ? If a site admin already exclude a CA from the package in the config file, I expect that banned CA would not be downloaded with refreshCAPackage --force option.  %ENDCOLOR% %RED%(AP)That is correct. I think they might be downloaded (since all CAs come is a single tarball), but excluded files will not be present in the certDir. %ENDCOLOR%
   2.	<verbatim>fetchCRL</verbatim> It retrieves CRLs for all CAs within the directory. This will involve invoking fetch-crl, with appropriate arguments. *NOTE:*
      a.  The original document had an argument of  <CA hash or pattern>, but I am unclear about the reason for such an argument. What is the argument against downloading all the new CRLs, is it not better to have all new CRLs. Also we decided against providing option to refresh a singleCA, is there an advantage to have refresh for a single CRL.  If there is a good reason to support this argument we will need to add code in the fetch-crl to achieve this.
%BLUE%(MA) I argued the need for refreshing a single CA files above. Again, it may be possible a single CA's cert is about to expire or CRL location is moved or signing policy is changed, in those cases, it is better to refresh a single CA files. Similarly, if a CA's CRL is about to expire, a admin would want to run fetchCRL command ahead of its scheduled time and grab the CRLs for that CA. I cannot think of an argument against downloading all of the CA files and CRLs instead of a single one. Perhaps it is better to keep the above two commands without a single CA input %ENDCOLOR% %RED%(AP) I would agree with keeping the above two commands without a singleCA input %ENDCOLOR%
      b. The original specification has a --force option for fetchCRL. After going through the current fetch-crl code, I am concerned about the wisdom of providing the --force option. What exactly are we forcing by this option? We might end up replacing the current with a older CRL (i.e. LastUpdateOfDownloadedCRL  <  LastUpdateOfCurrentCRL ). Adding this functionality into fetch-crl is not difficult but do we really want to support this?%BLUE% (MA) I cannot remember how the original fetch-crl --force works. %RED%(AP) Just to be clear there is no --force option in the current fetch-crl.%ENDCOLOR% I think fetch-crl does not do a download if the CRL file on disk is identical to the online copy. %RED%(AP) I believe the CRLs get downloaded on every fetch-crl run, but replacement occurs only if newer version is found. %ENDCOLOR% By forcing it, the download happens anyway. When I wrote the specification, I did not think about the fetch-crl --force option. What I needed was : fetchCRL will run every 24 hours to grab CRLs. If a new CRL is not published, it will not fetch anything.  fetchCRL --force will grab CRLs regardless they are updated or not. I do not understand Anand's question on replacing current CRL with an older one. I assumed the online copy from the CA is always the most current copy. %ENDCOLOR% %RED%(AP)  Currently fetch-crl downloads the crl file from the listed url and ends up replacing the existing file only if the downloaded file is newer. The problem is that there can be multiple copies of the crl files, i.e. the current fetch-crl code allows the possibility of multiple url entries in the crl_url file. If we remove this check and force the overwrite of the existing file with the downloaded version, I can see a potential case where one of the url's (in crl_url) file has a more recent version (ideally they all urls will be uptodate and same version). Ergo we could endup with an older crl just because  checks were ignored.%ENDCOLOR%%BLUE% that is fine Anand, but i should understand more why there are multiple CRLs and how current vdt-update-cert file picks among the multiple crl locations %ENDCOLOR%%RED% To clarify: multiple crl_url are possible not necessary. vdt-update-certs does not download crls, it is fetch-crl which handles them. For all urls listed in the .crl_url file, fetch-crl downloads the crls from each location one-by-one and makes sure that the latest CRL is put in the <\certDir\>. %ENDCOLOR%
   3.	<verbatim>setDistributionURL [--url <URL_location>]</verbatim> This command sets the location from where the CA files.  This command will modify vdt-update-certs.conf and set the cacerts_url as <URL_location>. %BLUE% (MA) why do we want to invoke refreshCAPackage and fetchCRL automatically?  I think it is better to keep functionalities separate. By running too many things automatically, we may make it harder for the site admin to follow. I would say once this command finishes, print out message to prompt them to run refreshCAPackage and fetchCRL %ENDCOLOR% %RED%(AP) OK. Proposed --autorefresh & --norefresh options would be useful to suppress the prompts. With such elaborate syntax adding prompts can be irritating to user. %ENDCOLOR% Finally it will automatically invoke refreshCAPackage and fetchCRL commands to download updated CAs and the corresponding CRLs. (Should these commands be invoked with a –force option). The distribution  \<URL_location\> will be required to conform to the format similar to http://vdt.cs.wisc.edu/software/certificates/ca-certs-version (I believe this is VDT specific format,  not standardized IGTF format, correct?). If the \<URL_location\> cannot be reached or does not conform to the format requirements a warning will be issues and no changes will be made. %BLUE% (MA) I think even if we do not run refreshCAPackage command automatically, we should still check if the given URL is valid syntactically. If for example URL is nor conforming, an error will be issues. If force option is used, teh URL will be innserted into the config file. %ENDCOLOR% %RED%(AP) Yes that is the plan. Running refreshCAPackagehas nothing to do with checking validity of the URL and its content. Ofcourse --force will give a warning that update-vdt-certs will no longer work and make the change anyway. %ENDCOLOR% The --force option can be used to force a change ignoring the warning . If URL location is left unspecified the \<URL_location\> will be set to OSG default. As a lower priority we can define keywords for OSG, VDT, VDT-IGTF, etc to indicate well-known CA URL_locations. %BLUE% (MA) I like the default idea and keywords%ENDCOLOR% %RED%(AP) Good. %ENDCOLOR%
   4.	<verbatim>add [--dir <local_dir>] --hash <CA_hash></verbatim> The --hash argument is required.  If --dir is not specified we will assume that the user wants to include a CA he has previously excluded and will remove the corresponding exclude lines from the config.%BLUE% (MA) I suppose you will also bring back the removed CA files into the certDir.%ENDCOLOR% %RED%(AP) NO! This tool is not in the business of adding or removing the cert files directly. It will call vdt-update-certs to get the cert files added or removed and hence we will not maintain a backup of the removed certs. If the user adds it back then the file that is in the OSG/VDT package, it is fetched cache by the vdt-update-certs script. If it was a user specific cert file then it will never be listed in exclude option to begin with. %ENDCOLOR% If \<CA_hash\> is not known to us or it is already included we will provide appropriate error/warning information.  In the common case this command will add include lines for \<local_dir\>/\<CA_hash\>.*, into the vdt-update-certs.conf file. Lastly the command will invoke functions refresh the CAs and fetch CRLs. This command will also do some preliminary error checks, e.g. make sure that “.0”, “.crl_url”, “.signing_policy” files exist and that --dir is different than --certDir. NOTE: I am avoiding <pattern> option for add and remove since, I believe it is necessary for the site admin to unambiguity understand what CA he is adding or removing, patterns can lead to unintended consequences. He can always search for pattern using the listCA command.
   5.	<verbatim>remove --hash <CA_hash></verbatim> This command will be complementary to add and would either add an exclude or remove an include depending on the scenario. This command will also refresh CA and CRLs. %BLUE% (MA) should not this command move the CA files into a temporary directory? %ENDCOLOR% %RED%(AP) Again as mentioned in add this tool will not save the removed cert files. If the removed files are included in the VDT/OSG they can be brough back, if they are user specific then the user already has a copy (which is what the vdt-update-cert uses to find file) of the cert file. %ENDCOLOR%

%BLUE% (MA) Anand for some of the features, you may have to create a logging capability into vdt-update-certs or intil ca_mgmt tool. I am nto against either one. and I support your decision on adding extended logging into any one of them %ENDCOLOR%
---++++ Notes:
   1.	Find and decide which openssl to use, either the one in $VDT_LOCATION/globus/bin or the one in /usr/bin or equivalent %GREEN%(AR) The VDT uses the system OpenSSL, so you should too. The one in globus/bin just points at the system one. %ENDCOLOR%
   2.	Check using rpm -q -whatprovides to see if the package has been installed using RPM. %GREEN%(AR) Be careful--we install on platforms that don't use RPM, so only do this if rpm exists. %ENDCOLOR%
   3.	What kind of logging should this script provide and where should these logs be stored? vdt-install.log? %GREEN%(AR) No, not vdt-install.log. It's not clear to me that we need a log at all, but you can put it into $VDT_LOCATION/var/log if you need it %ENDCOLOR%
%BLUE% (MA) I think logging is very useful. I would like to see when a update succeeded, failed, where it was downloaded, which package used. This is very useful especially when config file is modified over a span of time and earlier configurations are lost. The logs would be used to help listCA command, where we can show which package and when the files on disk have been downloaded from. Note that after the last update the config file may have been modified. %ENDCOLOR%

%RED% (AP) I would tend to agree with Alain that we don't have much log information to record. We can probably record what commands were run, what changes were made to the config file, when the update command was run. As to whether the update succeeded, failed, where it was downloaded, and which package used, will have to be recorded in the vdt-update-certs not in the log from this tool. %ENDCOLOR%

   4.	All options/commands will be case insensitive.
   5.	\<pattern\> will follow perl regular expression


---+++ TIMELINE AND MANAGEMENT PLAN  

__Please update your assigned tasks below__

|*DueDate*|*Person Responsible*|*Involved People (either helping or approving)*|*Task Description*|*Logs/Comments/Updates*|
| 9/12| Mine and Alain|None|Understand OSG sites’ needs: whether they use RPMs or not. If OSG sites do not need RPM installations for CA distributions, then implement the above tool only for Pacman repository|We will not consider RPM implementation for now. Decided on 9/15| 
|9/22|Alain|None|Code repository. VDT's SVN will be used for repository. Alain provide access to Anand| | 
|9/22|Anand|Alain helps|A list of all security scripts in VDT will be documented: how they work currently and they the scripts interact. How how the existing code will be reused in any of the above options| |
|9/22|Alain|None|The recent changes to the vdt-update-certs and vdt-update-certs.conf files will be documented and examined.|http://vdt.cs.wisc.edu/releases/1.10.1/man/vdt-update-certs.html | 
|9/29|Anand|Alain, Jim, Mine|A detailed document stating how the tool will work. This document will describe the execution steps for each capability above and describe the choices made. | |
|10/20|Anand|Alain, Mine, Jim|Implementation of the code| |
|11/17|ITB, Alain, Suchandra| Anand, Mine, Jim|Testing of the new code| | 




-- Main.MineAltunay - 16 Sep 2008
%META:TOPICINFO{author="IanRoss" date="1469137996" format="1.1" version="1.4"}%
%META:TOPICPARENT{name="UserSchool16Materials"}%
<style type="text/css">
pre em { font-style: normal; background-color: yellow; }
pre strong { font-style: normal; font-weight: bold; color: #008; }
</style>

---+ Monday Exercise 2.4: Use queue _N_, $(Cluster), and $(Process)

The goal of this exercise is to learn to submit many jobs from a single =queue= statement, and then to control filenames and arguments per job.

---++ Submitting Many Jobs With One Submit File

Suppose you have a program that you want to run many times. The program takes an argument, and you want to change the argument for each run of the program. With what you know so far, you have a couple of choices (assuming that you cannot change the job itself to work this way):

   * Write one submit file; submit one job, change the argument in the submit file, submit another job, change the submit file, …
   * Write many submit files that are nearly identical except for the program argument

Neither of these options seems very satisfying. Fortunately, we can do better with HTCondor.

---++ Running Many Jobs With One queue Statement

Here is a simple C program that uses a simple statistic method to estimate the value of &Pi. The argument \
is the number of samples to take -- more samples should equate to better estimates!

<pre class="file">
</pre>

Now suppose that you want to run this program a few times, in order to get multiple estimates.  It turns out, the =queue= statement in an \
HTCondor submit file takes an optional argument: the number of jobs to queue. Here is a single HTCondor submit file that will run three jobs: 

<pre class="file">
universe = vanilla
executable = fibonacci.py
log = pi.log
should_transfer_files = YES
when_to_transfer_output = ON_EXIT

output = pi.out
error  = pi.err
arguments = 1

<em>queue 3</em>
</pre>

Let’s see exactly what happens when you submit a file with =queue 3=.  

   1. Create a new directory for this exercise. 
   1. Save the Python program to a file named =fibonacci.py=
   1. Save the submit file
   1. Submit the submit file\
       <p>Note the slightly different message from =condor_submit=:</p>\
       <pre class="screen"><em>3 job(s)</em> submitted to cluster <i>NNNN</i>.</pre>
   1. Before the jobs execute, run =condor_q= (or =condor_q <em>userid</em>=) to see your jobs in the queue

Here is some sample =condor_q= output from my test run:

<pre class="screen">
2441<em>.0</em>   cat             6/24 11:57   0+00:00:00 I  0   0.0  fibonacci.py      
2441<em>.1</em>   cat             6/24 11:57   0+00:00:00 I  0   0.0  fibonacci.py      
2441<em>.2</em>   cat             6/24 11:57   0+00:00:00 I  0   0.0  fibonacci.py      
</pre>

In this sample, all three jobs are part of cluster =2441=. The first =queue= statement resulted in process =0=, the second =queue= statement resulting in process =1=, and the third one resulted in process =2=. 

(Historical note: Programmers like to start counting from 0, hence the odd numbering scheme.)

At this time, it is worth reviewing the definition of a __job ID__. It is a job’s cluster number, a dot, and the job’s process number. So in the example above, the job ID that corresponds to the second =queue= statement is =2441.1=.

*Pop Quiz:* Do you remember how to ask HTCondor to list all of the jobs from one cluster? How about a particular job ID?

---++ Using queue _N_ With Output

Look at your jobs that just ran and completed.  

   1. What happens if you queue many jobs with a single =queue= statement, and those jobs produce output? 
   1. What is desired? 

We need a way to distinguish between the jobs, both to pass different arguments to the script and to label unique output files.  Luckily, \
this mechanism is already in place when we use the =queue N= syntax.  

---++ Using $(Process) to Distinguish Jobs

When processing a submit file, HTCondor defines and uses a special variable for the process number of each job. If you write =$(Process)= in a submit file, HTCondor will replace it with the process number of the job, independently for each job added to the queue. Using this variable allows you, for example, to define an output file per process. For example, suppose the following two lines occur in a submit file:

<pre class="file">
output = my-output-file-$(Process).out
queue 10
</pre>

Even though the =output= is the “same” for each job created by the =queue 10= statement, the actual output filename will be different for each job:

| First job | =my-output-file-0.out= |
| Second job | =my-output-file-1.out= |
| Third job | =my-output-file-2.out= |
| ... ||
| Last (tenth) job | =my-output-file-9.out= |

We can also use this =$(Process)= variable as an argument to our =fibonacci.py= script.  

Let’s try this in a real example.

   1. Edit your submit file: 
      1. use =$(Process)= to name each output and error file uniquely
      1. pass =$(Process)= to the job executable (=fibonacci.py=) using the =arguments= line.  
   1. Submit your jobs, wait for them to finish, then look at the output

Did you get 3 output files, each named differently? Does each one have a different value?  

---++ Using $(Cluster) to Separate Files Across Runs

As it stands now, you can get separate output (and error) filenames for each job within a run. However, the next time you submit the same file, all of the output and error files are overwritten by new ones created by the new jobs. Maybe this is the behavior that you want. But sometimes, you may want to separate files by run, as well.

In addition to =$(Process)=, there is also a =$(Cluster)= variable that you can use in your submit files. It works just like =$(Process)=, except it is replaced with the cluster number of the entire submission. Obviously, the cluster number is the same for all jobs within a single submission, so it does not help separate files by job. But when used *with* =$(Process)=, it can be used to separate files by run. For example, consider this =output= statement:

<pre class="file">
output = my-output-file-$(Cluster)-$(Process).out
</pre>

For one particular run, it might result in output filenames like this:

| First job | =my-output-file-2444-0.out= |
| Second job | =my-output-file-2444-1.out= |
| Third job | =my-output-file-2444-2.out= |
| ... ||

If you like, change your submit file from the previous exercise to use both =$(Cluster)= and =$(Process)=. Submit your file twice to see the separate files for each run. Be careful how many jobs you run total, as the number of output files grows quickly!


---++ Using $(Process) and $(Cluster) in Other Statements

The =$(Cluster)= and =$(Process)= variables can be used in any submit file statement, although they seem to be useful in some kinds of statements more than others. For instance, it is hard to imagine a truly good reason to use the =$(Process)= variable in a =rank= statement (i.e., for preferring some execute slots over others), and in general the =$(Cluster)= variable often makes little sense to use.

But in some situations, the =$(Process)= variable can be very helpful. Common uses are in the following kinds of statements — can you think of a scenario in which each use might be helpful?

   * =log=
   * =transfer_input_files=
   * =transfer_output_files=
   * =arguments=

Unfortunately, HTCondor does not let you perform math on the =$(Process)= number when using it. So, for example, if you use =$(Process)= as a numeric argument to a command, it will always result in jobs getting the arguments 0, 1, 2, and so on. If you have control over your program and the way in which it uses command-line arguments, then you are fine. Otherwise, you might need to transform the =$(Process)= numbers into something more appropriate using a __wrapper script__, which will be discussed on Wednesday.

---++ (Optional) Defining Extra Attributes for Tracking

During the lecture, it was mentioned that you can define arbitrary attributes in your submit file, and that one purpose of such attributes is to track or report on different jobs separately. In this optional exercise, you will see how this technique can be used.

Once again, we will use =sleep= jobs, so that your jobs remain in the queue long enough to experiment on.

   1. Create a basic submit file that runs =sleep 120= (or some reasonable duration)
   1. Instead of a single =queue= statement, write this:\
       <pre class="file">
<em>+MyJobAttribute = 1</em>
queue 5
<em>+MyJobAttribute = 2</em>
queue 5
</pre>\
       <p>The highlighted statements give the extra attribute =MyJobAttribute= to your jobs; the first 5 jobs have one value, and the second 5 have another.
   1. Submit the file

Check on the submissions using a normal =condor_q=. Of course, your special attribute does not appear in the standard =condor_q= output, but it is present in each job’s !ClassAd. You can see the effect of the attribute by limiting your =condor_q= output to one type of job or another. First, run this command:

<pre class="screen">
%UCL_PROMPT_SHORT% <strong>condor_q -constraint 'Owner == "<em>userid</em>" && MyJobAttribute == 1'</strong>
</pre>

Use your own =userid=, of course. Do you get the output that you expected?

Using the example command above, how would you list your other five jobs?
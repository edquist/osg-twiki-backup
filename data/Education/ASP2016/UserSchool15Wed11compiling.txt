%META:TOPICINFO{author="ChristinaKoch" date="1436986710" format="1.1" reprev="1.2" version="1.2"}%
%META:TOPICPARENT{name="UserSchool15Materials"}%
<style type="text/css">
pre em { font-style: normal; background-color: yellow; }
pre strong { font-style: normal; font-weight: bold; color: #008; }
</style>

---+ Wednesday Exercise 1.2: Using a pre-compiled binary

blah blah blah

---++ Our software example

For our example, we will use a script written in =c=, as =c= code frequently depends 
on libraries and therefore will benefit from being statically compiled


<pre class="file">
#include &ltstdio.h&gt
 
long factorial(int);
 
int main()
{
   int i, n, c;
   n=7;
   for (i = 0; i < n; i++){
      for (c = 0; c <= (n - i - 2); c++)
         printf(" ");
      for (c = 0 ; c <= i; c++)
         printf("%ld ",factorial(i)/(factorial(c)*factorial(i-c)));
      printf("\n");
   }
   return 0;
}

long factorial(int n)
{
   int c;
   long result = 1;
   for (c = 1; c <= n; c++)
         result = result*c;
   return result;
}
</pre>
---++ Compiling

In order to submit this job, we will first need to statically compile our piece of C code.  
We should *not* compile the code from where we are on the submit node; compilation 
can be an intensive process and could compromise the performance of the submit node.  
Instead, we are going to compile our code within an interactive session, which must be 
launched from the CHTC (not OSG) submit point.  

(talk about transferring files)

Most linux servers have the =gcc= (GNU compiler collection) installed, so we simply 
need an interactive session on any machine in the CHTC pool.  The mechanism for 
getting a bash session is submitting an interactive job.  An interactive job is essentially 
a job without an executable; you are the one running the commands instead 
(in this case, to compile the C code).  

Our interactive job will be submitted using a submit file.  Notice that there is no 
executable listed!

<pre class="file">
universe = vanilla

output = compile.out
error = compile.err
log = compile.log

should_transfer_files = YES
when_to_transfer_output = ON_EXIT

transfer_input_files = pascal.c

queue
</pre>

<pre class="screen">
%UCL_PROMPT_SHORT% <strong>gcc -static pascal.c -o pascal</strong>
</pre>

---++ Submit file

<pre class="file">
universe = vanilla
executable = pascal

output = pascal.out
error = pascal.err
log = pascal.log

should_transfer_files = YES
when_to_transfer_output = ON_EXIT

queue
</pre>
